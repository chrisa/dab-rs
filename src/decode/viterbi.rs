use libm::erf;
use std::f64::consts::SQRT_2;

const OFFSET: f64 = 128.0;
const K: i32 = 7;
const N: i32 = 4;

const LONGBITS: i32 = 32;
const LOGLONGBITS: i32 = 5;
const D: i32 = 1 << (K - LOGLONGBITS - 1);

pub struct Viterbi {
    table49: Box<[i32; 2048]>,
    syms: Box<[usize; 1 << K]>,
}

pub fn new_viterbi() -> Viterbi {
    let mut v = Viterbi {
        table49: Box::new([0; 2048]),
        syms: Box::new([0; 1 << K]),
    };
    v.gen_table49();
    v.vd_init();
    v
}

// Normal function integrated from -Inf to x. Range: 0-1
fn normal(x: f64) -> f64 {
    0.5 + 0.5 * erf(x / SQRT_2)
}

fn parity(i: usize) -> usize {
    let mut x = i;
    x ^= x >> 16;
    x ^= x >> 8;
    Partab[x & 0xff]
}

/* 8-bit parity lookup table, generated by partab.c */
const Partab: [usize; 256] = [
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
];

/* Rate 1/4 codes */
const Polys: [usize; 4] = [0x6d, 0x4f, 0x53, 0x6d]; /* k = 7; DAB  */

impl Viterbi {
    fn vd_init(&mut self) {
        for i in 0..(1 << K as usize) {
            let mut sym = 0;
            for p in Polys {
                sym = (sym << 1) + parity(i & p);
                self.syms[i] = sym;
            }
        }
    }

    fn gen_table49(&mut self) {
        let mut KI: [i32; 2048] = [0; 2048];

        KI[0] = 0;
        for i in 1..2048 {
            KI[i] = (13 * KI[i - 1] + 511) % 2048;
        }

        let mut n = 0;
        for k in KI {
            if (256..=1792).contains(&k) && (k != 1024) {
                self.table49[n] = k - 1024;
                n += 1;
            }
        }
    }

    pub fn frequency_deinterleave(&self, bits: &[bool]) -> Vec<bool> {
        let mut slice = vec!();
        slice.resize(bits.len(), false);
        let k1 = 1536;
        for i in 0..k1 {
            let mut k = self.table49[i as usize];

            k += match k {
                n if n < 0 => k1 / 2,
                n if n > 0 => k1 / 2 - 1,
                _ => 0,
            };
            assert!(k >= 0);
            assert!(k < 1536);

            slice[2 * i as usize] = bits[2 * k as usize];
            slice[2 * i as usize + 1] = bits[2 * k as usize + 1];
        }

        slice
    }

    pub fn viterbi(&self, bits: &[bool]) -> Vec<bool> {
        assert!(bits.len() == 3096);
        
        let mut result = vec!();
        result.resize(768,false);

        let mut bitcnt = -(K - 1);

        let mut m0: i32;
        let mut m1: i32;

        let mut mets: [i32; 1 << N] = [0; 1 << N];
        const nbits: i32 = 768;

        let mut paths: [u32; ((nbits + K - 1) * D) as usize] = [0; ((nbits + K - 1) * D) as usize];

        let mut cmetric: [i32; 1 << (K - 1)] = [0i32; 1 << (K - 1)];
        let mut nmetric: [i32; 1 << (K - 1)] = [0i32; 1 << (K - 1)];

        let mut mask: u32 = 1;

        let mut startstate: usize = 0;
        let mut endstate: usize = 0;

        startstate &= !((1 << (K - 1)) - 1);
        endstate &= !((1 << (K - 1)) - 1);

        /* Initialize starting metrics */
        for c in cmetric.iter_mut().take(1 << (K - 1)) {
            *c = -999999;
        }
        cmetric[startstate] = 0;

        let mut path_offset: usize = 0;
        let mut symbol_offset: usize = 0;

        let metrics = [[3, -7], [-7, 3]];

        loop {
            /* For each data bit */
            /* Read input symbols and compute branch metrics */
            for (i, met) in mets.iter_mut().enumerate().take(1 << N) {
                *met = 0;
                for j in 0..N as usize {
                    *met += metrics[(i >> (N as usize - j - 1)) & 1]
                        [if bits[symbol_offset + j] { 1 } else { 0 }];
                }
            }

            symbol_offset += N as usize;

            /* Run the add-compare-select operations */
            let mut i = 0;
            loop {
                let mut b1 = mets[self.syms[i]];
                nmetric[i] = cmetric[i / 2] + b1;
                m0 = cmetric[i / 2] + b1;
                let b2 = mets[self.syms[i + 1]];
                b1 -= b2;
                m1 = cmetric[(i / 2) + (1 << (K - 2))] + b2;
                if m1 > m0 {
                    nmetric[i] = m1;
                    paths[path_offset] |= mask;
                }
                m0 -= b1;
                nmetric[i + 1] = m0;
                m1 += b1;
                if m1 > m0 {
                    nmetric[i + 1] = m1;
                    paths[path_offset] |= mask << 1;
                }
                mask <<= 2;
                if mask == 0 {
                    mask = 1;
                    path_offset += 1;
                }

                i += 2;
                if i >= (1 << (K - 1)) {
                    break;
                }
            }

            if mask != 1 {
                path_offset += 1;
            }
            bitcnt += 1;
            if bitcnt == nbits {
                break;
            }
            cmetric.copy_from_slice(&nmetric);
        }

        /* Chain back from terminal state to produce decoded data */
        for i in (0..(nbits as usize)).rev() {
            path_offset -= D as usize;

            if (paths[path_offset + (endstate >> LOGLONGBITS)]
                & (1u32 << (endstate & (LONGBITS as usize - 1))))
                != 0
            {
                endstate |= 1 << (K - 1);
                result[i] = true;
            }
            endstate >>= 1;
        }

        result
    }
}
