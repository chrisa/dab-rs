use libm::erf;
use std::f64::consts::SQRT_2;

const OFFSET: f64 = 128.0;
const K: i32 = 7;
const N: i32 = 4;

const LONGBITS: i32 = 32;
const LOGLONGBITS: i32 = 5;
const D: i32 = 1 << (K - LOGLONGBITS - 1);

pub struct Viterbi {
    metrics: Box<[[i32; 256]; 2]>,
    table49: Box<[i32; 2048]>,
    syms: Box<[usize; 1 << K]>,
}

pub fn new_viterbi() -> Viterbi {
    let mut v = Viterbi {
        metrics: Box::new([[0; 256]; 2]),
        table49: Box::new([0; 2048]),
        syms: Box::new([0; 1 << K]),
    };
    v.gen_metrics();
    v.gen_table49();
    v.vd_init();
    v
}

// Normal function integrated from -Inf to x. Range: 0-1
fn normal(x: f64) -> f64 {
    0.5 + 0.5 * erf(x / SQRT_2)
}

fn map_symbol(bit: u8) -> usize {
    match bit {
        1 => 129,
        0 => 127,
        _ => 128,
    }
}

fn parity(i: usize) -> usize {
    let mut x = i;
    x ^= x >> 16;
    x ^= x >> 8;
    Partab[x & 0xff]
}

/* 8-bit parity lookup table, generated by partab.c */
const Partab: [usize; 256] = [
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
];

/* Rate 1/4 codes */
const Polys: [usize; 4] = [0x6d, 0x4f, 0x53, 0x6d]; /* k = 7; DAB  */
//<=== bit rev of 5b 79 65 5b

impl Viterbi {
    fn vd_init(&mut self) {
        // for i in 0..(1 << K as usize) {
        //     let mut sym = 0;
        //     for j in 0..N as usize {
        //         sym = (sym << 1) + parity(i & Polys[j]);
        //         self.syms[i] = sym;
        //     }
        // }

        self.syms = Box::new([
            0, 15, 6, 9, 13, 2, 11, 4, 13, 2, 11, 4, 0, 15, 6, 9, 2, 13, 4, 11, 15, 0, 9, 6, 15, 0, 9, 6, 2, 13, 4, 11, 9, 6, 15, 0, 4, 11, 2, 13, 4, 11, 2, 13, 9, 6, 15, 0, 11, 4, 13, 2, 6, 9, 0, 15, 6, 9, 0, 15, 11, 4, 13, 2, 15, 0, 9, 6, 2, 13, 4, 11, 2, 13, 4, 11, 15, 0, 9, 6, 13, 2, 11, 4, 0, 15, 6, 9, 0, 15, 6, 9, 13, 2, 11, 4, 6, 9, 0, 15, 11, 4, 13, 2, 11, 4, 13, 2, 6, 9, 0, 15, 4, 11, 2, 13, 9, 6, 15, 0, 9, 6, 15, 0, 4, 11, 2, 13
        ]);

        //, dbg!(&self.syms);
    }

    fn gen_metrics(&mut self) {
        let amp: f64 = 1.0;
        let noise: f64 = 1.0;
        let bias: f64 = 0.0;
        let scale: f64 = 4.0;

        let mut metrics: [[f64; 256]; 2] = [[0.0; 256]; 2];

        {
            let p1 = normal(((0.0 - OFFSET + 0.5) / amp - 1.0) / noise);
            let p0 = normal(((0.0 - OFFSET + 0.5) / amp + 1.0) / noise);
            metrics[0][0] = (2.0 * p0 / (p1 + p0)).log2() - bias;
            metrics[1][0] = (2.0 * p1 / (p1 + p0)).log2() - bias;
        }

        for s in 1..255 {
            let p1 = normal(((s as f64 - OFFSET + 0.5) / amp - 1.0) / noise)
                - normal(((s as f64 - OFFSET - 0.5) / amp - 1.0) / noise);
            let p0 = normal(((s as f64 - OFFSET + 0.5) / amp + 1.0) / noise)
                - normal(((s as f64 - OFFSET - 0.5) / amp + 1.0) / noise);
            metrics[0][s] = (2.0 * p0 / (p1 + p0)).log2() - bias;
            metrics[1][s] = (2.0 * p1 / (p1 + p0)).log2() - bias;
        }

        {
            let p1 = 1.0 - normal(((255.0 - OFFSET - 0.5) / amp - 1.0) / noise);
            let p0 = 1.0 - normal(((255.0 - OFFSET - 0.5) / amp + 1.0) / noise);
            metrics[0][255] = (2.0 * p0 / (p1 + p0)).log2() - bias;
            metrics[1][255] = (2.0 * p1 / (p1 + p0)).log2() - bias;
        }

        for bit in 0..2 {
            for s in 0..256 {
                self.metrics[bit][s] = match (metrics[bit][s] * scale + 0.5).floor() {
                    x if x.is_nan() => i32::MIN,
                    f64::NEG_INFINITY => i32::MIN,
                    other => other as i32,
                };
            }
        }

        // dbg!(&self.metrics);
    }

    fn gen_table49(&mut self) {
        let mut KI: [i32; 2048] = [0; 2048];

        KI[0] = 0;
        for i in 1..2048 {
            KI[i] = (13 * KI[i - 1] + 511) % 2048;
        }

        let mut n = 0;
        for i in 0..2048 {
            if (KI[i] >= 256) && (KI[i] <= 1792) && (KI[i] != 1024) {
                self.table49[n] = KI[i] - 1024;
                n += 1;
            }
        }

        // dbg!(&self.table49);
    }

    pub fn frequency_deinterleave(&self, bits: [u8; 3072]) -> [u8; 3072] {
        let mut slice = [0u8; 3072];
        let k1 = 1536;
        for i in 0..k1 {
            let mut k = self.table49[i as usize];

            k += match k {
                n if n < 0 => k1 / 2,
                n if n > 0 => k1 / 2 - 1,
                _ => 0,
            };
            // dbg!(k);
            assert!(k >= 0);
            assert!(k < 1536);
            // now, 0x0 <= k < 1536 (?)

            slice[2 * i as usize] = bits[2 * k as usize];
            slice[2 * i as usize + 1] = bits[2 * k as usize + 1];
        }

        slice
    }

    pub fn viterbi(&self, bits: [u8; 3096]) -> [u8; 768] {
        let mut result = [0u8; 768];
        let symbols = bits.map(map_symbol);

        // dbg!(symbols);

        let mut bitcnt = -(K - 1);

        let mut m0: i32;
        let mut m1: i32;

        let mut mets: [i32; 1 << N] = [0; 1 << N];
        const nbits: i32 = 768;

        let mut paths: [u32; ((nbits + K - 1) * D) as usize] = [0; ((nbits + K - 1) * D) as usize];

        let mut cmetric: [i32; 1 << (K - 1)] = [0i32; 1 << (K - 1)];
        let mut nmetric: [i32; 1 << (K - 1)] = [0i32; 1 << (K - 1)];

        let mut mask: u32 = 1;

        let mut startstate: usize = 0;
        let mut endstate: usize = 0;

        startstate &= !((1 << (K - 1)) - 1);
        endstate &= !((1 << (K - 1)) - 1);

        // dbg!(bitcnt);
        // dbg!(nbits);

        /* Initialize starting metrics */
        for i in 0..(1 << (K - 1)) {
            cmetric[i] = -999999;
        }
        cmetric[startstate] = 0;

        let mut path_offset: usize = 0;
        let mut symbol_offset: usize = 0;

        loop {
            /* For each data bit */
            /* Read input symbols and compute branch metrics */
            for i in 0..(1 << N) {
                mets[i] = 0;
                for j in 0..N as usize {
                    mets[i] += self.metrics[(i >> (N as usize - j - 1)) & 1]
                        [symbols[symbol_offset + j]] as i32;
                }
            }

            // dbg!(mets);

            symbol_offset += N as usize;
          
        //   dbg!(mets);
        //   dbg!(&self.syms);

            /* Run the add-compare-select operations */
            let mut i = 0;
            loop {
                let mut b1 = mets[self.syms[i]];
                nmetric[i] = cmetric[i / 2] + b1;
                m0 = cmetric[i / 2] + b1;
                let b2 = mets[self.syms[i + 1]];
                // print!("b {} {} ", b1, b2);
                b1 -= b2;
                m1 = cmetric[(i / 2) + (1 << (K - 2))] + b2;
                if m1 > m0 {
                    nmetric[i] = m1;
                    paths[path_offset] |= mask;
                }
                m0 -= b1;
                nmetric[i + 1] = m0;
                m1 += b1;
                if m1 > m0 {
                    nmetric[i + 1] = m1;
                    paths[path_offset] |= mask << 1;
                }
                mask <<= 2;
                if mask == 0 {
                    mask = 1;
                    path_offset += 1;
                }
                // print!("{:?} ", path_offset);

                i += 2;
                if i >= (1 << (K - 1)) {
                    break;
                }
            }
            // println!("");

            if mask != 1 {
                path_offset += 1;
            }
            bitcnt += 1;
            if bitcnt == nbits {
                break;
            }
            cmetric.copy_from_slice(&nmetric);
        }

        // dbg!(cmetric);

        // dbg!(nbits);
        // dbg!(paths);
        // dbg!(path_offset);
        // dbg!(D);

        /* Chain back from terminal state to produce decoded data */
        for i in (0..(nbits as usize)).rev() {
            path_offset -= D as usize;

            // dbg!(path_offset);
            // dbg!(endstate);
            // dbg!(paths[path_offset + (endstate >> LOGLONGBITS)]);
            // dbg!(1u64 << (endstate & (LONGBITS as usize - 1)));

            if (paths[path_offset + (endstate >> LOGLONGBITS)]
                & (1u32 << (endstate & (LONGBITS as usize - 1))))
                != 0
            {
                endstate |= 1 << (K - 1);
                result[i] = 1;
            }
            endstate >>= 1;

            // dbg!(endstate);
        }

        result
    }
}
