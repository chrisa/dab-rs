// wffirecrc.rs
//
// Copyright (C) 2008 David Crawley
// Translated to Rust
//
// This file is a translation of the OpenDAB wffirecrc.c CRC check routine.
// Behavior is preserved: compute a 16-bit "Fire" CRC for bytes 2..10 and
// validate against bytes 0..1 of the buffer.

#![allow(dead_code)]

/// FIRE polynomial (kept for reference; not used directly in table-driven code)
const FIRE_POLY: u16 = 0x782f;

/// Lookup table from original C implementation (256 entries).
const FTAB: [u16; 256] = [
    0x0000, 0x782f, 0xf05e, 0x8871, 0x9893, 0xe0bc, 0x68cd, 0x10e2,
    0x4909, 0x3126, 0xb957, 0xc178, 0xd19a, 0xa9b5, 0x21c4, 0x59eb,
    0x9212, 0xea3d, 0x624c, 0x1a63, 0x0a81, 0x72ae, 0xfadf, 0x82f0,
    0xdb1b, 0xa334, 0x2b45, 0x536a, 0x4388, 0x3ba7, 0xb3d6, 0xcbf9,
    0x5c0b, 0x2424, 0xac55, 0xd47a, 0xc498, 0xbcb7, 0x34c6, 0x4ce9,
    0x1502, 0x6d2d, 0xe55c, 0x9d73, 0x8d91, 0xf5be, 0x7dcf, 0x05e0,
    0xce19, 0xb636, 0x3e47, 0x4668, 0x568a, 0x2ea5, 0xa6d4, 0xdefb,
    0x8710, 0xff3f, 0x774e, 0x0f61, 0x1f83, 0x67ac, 0xefdd, 0x97f2,
    0xb816, 0xc039, 0x4848, 0x3067, 0x2085, 0x58aa, 0xd0db, 0xa8f4,
    0xf11f, 0x8930, 0x0141, 0x796e, 0x698c, 0x11a3, 0x99d2, 0xe1fd,
    0x2a04, 0x522b, 0xda5a, 0xa275, 0xb297, 0xcab8, 0x42c9, 0x3ae6,
    0x630d, 0x1b22, 0x9353, 0xeb7c, 0xfb9e, 0x83b1, 0x0bc0, 0x73ef,
    0xe41d, 0x9c32, 0x1443, 0x6c6c, 0x7c8e, 0x04a1, 0x8cd0, 0xf4ff,
    0xad14, 0xd53b, 0x5d4a, 0x2565, 0x3587, 0x4da8, 0xc5d9, 0xbdf6,
    0x760f, 0x0e20, 0x8651, 0xfe7e, 0xee9c, 0x96b3, 0x1ec2, 0x66ed,
    0x3f06, 0x4729, 0xcf58, 0xb777, 0xa795, 0xdfba, 0x57cb, 0x2fe4,
    0x0803, 0x702c, 0xf85d, 0x8072, 0x9090, 0xe8bf, 0x60ce, 0x18e1,
    0x410a, 0x3925, 0xb154, 0xc97b, 0xd999, 0xa1b6, 0x29c7, 0x51e8,
    0x9a11, 0xe23e, 0x6a4f, 0x1260, 0x0282, 0x7aad, 0xf2dc, 0x8af3,
    0xd318, 0xab37, 0x2346, 0x5b69, 0x4b8b, 0x33a4, 0xbbd5, 0xc3fa,
    0x5408, 0x2c27, 0xa456, 0xdc79, 0xcc9b, 0xb4b4, 0x3cc5, 0x44ea,
    0x1d01, 0x652e, 0xed5f, 0x9570, 0x8592, 0xfdbd, 0x75cc, 0x0de3,
    0xc61a, 0xbe35, 0x3644, 0x4e6b, 0x5e89, 0x26a6, 0xaed7, 0xd6f8,
    0x8f13, 0xf73c, 0x7f4d, 0x0762, 0x1780, 0x6faf, 0xe7de, 0x9ff1,
    0xb015, 0xc83a, 0x404b, 0x3864, 0x2886, 0x50a9, 0xd8d8, 0xa0f7,
    0xf91c, 0x8133, 0x0942, 0x716d, 0x618f, 0x19a0, 0x91d1, 0xe9fe,
    0x2207, 0x5a28, 0xd259, 0xaa76, 0xba94, 0xc2bb, 0x4aca, 0x32e5,
    0x6b0e, 0x1321, 0x9b50, 0xe37f, 0xf39d, 0x8bb2, 0x03c3, 0x7bec,
    0xec1e, 0x9431, 0x1c40, 0x646f, 0x748d, 0x0ca2, 0x84d3, 0xfcfc,
    0xa517, 0xdd38, 0x5549, 0x2d66, 0x3d84, 0x45ab, 0xcdda, 0xb5f5,
    0x7e0c, 0x0623, 0x8e52, 0xf67d, 0xe69f, 0x9eb0, 0x16c1, 0x6eee,
    0x3705, 0x4f2a, 0xc75b, 0xbf74, 0xaf96, 0xd7b9, 0x5fc8, 0x27e7,
];

/// Compute the 16-bit Fire CRC for the 9 bytes in `slice`.
///
/// This implements the same loop as the original C routine that computes
/// the CRC from bytes 2..10 (9 bytes total). Returns the 16-bit CRC value.
fn compute_fire_crc_from_9_bytes(slice: &[u8]) -> u16 {
    assert!(slice.len() >= 9, "slice must have at least 9 bytes");
    let mut crc: u16 = 0x0000;
    for &b in &slice[..9] {
        // index = ((crc >> 8) ^ b) & 0xff
        let idx = (((crc >> 8) ^ (b as u16)) & 0xff) as usize;
        crc = (crc << 8) ^ FTAB[idx];
    }
    crc
}

/// Given a buffer (at least 11 bytes), check whether bytes 0..1 are the Fire CRC
/// for bytes 2..10 (inclusive). Returns true if CRC matches, false otherwise.
///
/// This mirrors the C function `firecrccheck(unsigned char* buf)`.
pub fn firecrccheck(buf: &[u8]) -> bool {
    if buf.len() < 11 {
        return false;
    }
    // Compute CRC on bytes 2..10
    let crc = compute_fire_crc_from_9_bytes(&buf[2..11]);
    let high = ((crc >> 8) & 0xff) as u8;
    let low = (crc & 0xff) as u8;
    (high == buf[0]) && (low == buf[1])
}

/// Helper to compute the two CRC bytes (high, low) for given 9 bytes slice.
pub fn fire_crc_bytes_for_9(slice: &[u8]) -> (u8, u8) {
    let crc = compute_fire_crc_from_9_bytes(slice);
    (((crc >> 8) & 0xff) as u8, (crc & 0xff) as u8)
}
